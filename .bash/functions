# vi: ft=sh

function setup_xdbus {
    local dbus="$HOME/.dbus/Xdbus"
    if [[ ! -f "$dbus" ]]; then
        touch "$dbus"
        chmod 600 "$dbus"
        env | grep DBUS_SESSION_BUS_ADDRESS > "$dbus"
        echo 'export DBUS_SESSION_BUS_ADDRESS' >> "$dbus"
    fi
}

HISTORY_TMP=/home/$USER/.backup/history.txt
function save_last_command {
    echo "$(date) $(hostname) [$(pwd)] $(history | tail -1)" >> "$HISTORY_TMP"
}

function get_username_color {
    if [[ "$(whoami)" == "root" ]]; then
        echo "\[\e[00;31m\]<><><> ROOT <><><>\[\e[0m\]"
        return
    fi
    local hhash=$(whoami| md5sum | grep "[0-9]" -o | paste -s -d+ - |bc)
    local hash_number=$(( hhash % 14 ))
    #echo "username $(whoami) hash $hhash hash_number $hash_number"
    case $hash_number in
         0) echo "\[\e[00;37m\]\u\[\e[0m\]";; ## username_white
         1) echo "\[\e[00;31m\]\u\[\e[0m\]";; ## username_red
         2) echo "\[\e[00;32m\]\u\[\e[0m\]";; ## username_green
         3) echo "\[\e[00;33m\]\u\[\e[0m\]";; ## username_yellow
         4) echo "\[\e[00;31m\]\u\[\e[0m\]";; ## username_red
         #4) echo "\[\e[00;34m\]\u\[\e[0m\]";; ## username_blue # not readable
         5) echo "\[\e[00;35m\]\u\[\e[0m\]";; ## username_purple
         6) echo "\[\e[00;35m\]\u\[\e[0m\]";; ## username_cyan
         ## bold colors
         7) echo "\[\e[01;37m\]\u\[\e[0m\]";; ## username_white
         8) echo "\[\e[01;31m\]\u\[\e[0m\]";; ## username_red
         9) echo "\[\e[01;32m\]\u\[\e[0m\]";; ## username_green
        10) echo "\[\e[01;33m\]\u\[\e[0m\]";; ## username_yellow
        11) echo "\[\e[01;31m\]\u\[\e[0m\]";; ## username_red
        #11) echo "\[\e[01;34m\]\u\[\e[0m\]";; ## username_blue # not readable
        12) echo "\[\e[01;35m\]\u\[\e[0m\]";; ## username_purple
        13) echo "\[\e[01;35m\]\u\[\e[0m\]";; ## username_cyan
    esac
}
function get_hostname_color {
    local hhash=$PROMPT_HOSTNAME_COLOR_HASH
    if [[ -z $hhash ]]; then
        hhash=$(hostname | md5sum | grep "[0-9]" -o | paste -s -d+ - |bc)
        export PROMPT_HOSTNAME_COLOR_HASH=$hhash
    fi
    local hash_number=$(( hhash % 14 ))
    case $hash_number in
         0) echo "\[\e[00;37m\]\h\[\e[0m\]";; ## hostname_white
         1) echo "\[\e[00;31m\]\h\[\e[0m\]";; ## hostname_red
         2) echo "\[\e[00;32m\]\h\[\e[0m\]";; ## hostname_green
         3) echo "\[\e[00;33m\]\h\[\e[0m\]";; ## hostname_yellow
         4) echo "\[\e[00;31m\]\h\[\e[0m\]";; ## hostname_red
         #4) echo "\[\e[00;34m\]\h\[\e[0m\]";; ## hostname_blue # not readable
         5) echo "\[\e[00;35m\]\h\[\e[0m\]";; ## hostname_purple
         6) echo "\[\e[00;35m\]\h\[\e[0m\]";; ## hostname_cyan
         ## bold colors
         7) echo "\[\e[01;37m\]\h\[\e[0m\]";; ## hostname_white
         8) echo "\[\e[01;31m\]\h\[\e[0m\]";; ## hostname_red
         9) echo "\[\e[01;32m\]\h\[\e[0m\]";; ## hostname_green
        10) echo "\[\e[01;33m\]\h\[\e[0m\]";; ## hostname_yellow
        11) echo "\[\e[01;31m\]\h\[\e[0m\]";; ## hostname_red
        #11) echo "\[\e[01;34m\]\h\[\e[0m\]";; ## hostname_blue # not readable
        12) echo "\[\e[01;35m\]\h\[\e[0m\]";; ## hostname_purple
        13) echo "\[\e[01;35m\]\h\[\e[0m\]";; ## hostname_cyan
    esac
}

function update_git_prompt {
    git rev-parse --git-dir &> /dev/null
    if [[ "$?" -ne "0" ]]; then
        export GIT_PROMPT=""
        return
    fi

    local git_root="$(basename "$(git rev-parse --show-toplevel)")"
    local current_branch="$(git branch | grep "^\*" | sed 's/^\* //')"
    CURRENT_BRANCH="\[\033[38;5;160m\][$current_branch]\[$(tput sgr0)\]"


    FILE_STATUS=""
    local untracked=$(git ls-files --others --exclude-standard | wc -l)
    if [[ "$untracked" -ne "0" ]]; then
        FILE_STATUS="\[\033[38;5;11m\]?\[$(tput sgr0)\]"
    fi
    local changed="$(git status | grep -c "modified:")"
    if [[ "$changed" -ne "0" ]]; then
        FILE_STATUS="$FILE_STATUS\[\033[38;5;208m\]++\[$(tput sgr0)\]"
    fi

    local outgoing="$(git log --branches --not --remotes=origin | wc -l)"
    local git_changes=""
    if [[ "$outgoing"  -ne "0" ]]; then
        git_changes=">>>>"
    fi

    GIT_PROMPT="$FILE_STATUS  $git_changes $CURRENT_BRANCH $git_root"
}

function update_battery_prompt {
    export BATTERY_PROMPT=""
    if [[ "$(acpi 2>&1 | grep Discharging -c)" -eq 1 ]]; then
        BATTERY_PROMPT="$(acpi | grep Discharging | cut -d ' ' -f4 | tr -d ',') "
    fi
}

function set_prompt_good {
    local EXIT_STATUS_GOOD="\[\e[00;32m\]#\[\e[0m\]"
    export PS1="$(set_prompt)\n$EXIT_STATUS_GOOD"
}

function set_prompt_bad {
    local EXIT_STATUS_BAD="\[\e[00;31m\]#\[\e[0m\]"
    export PS1="$(set_prompt)\n$EXIT_STATUS_BAD"
}

function set_prompt {
    #update_git_prompt
    #update_battery_prompt
    local PROMPT_DATE="\[\033[38;5;10m\]\d\[$(tput sgr0)\]\[\033[38;5;15m\] \[$(tput sgr0)\]\[\033[38;5;10m\]\t\[$(tput sgr0)\]"
    local PROMPT_USER_NAME="$(get_username_color)"
    local PROMPT_AT="\[\e[00;37m\]@\[\e[0m\]"
    local PROMPT_HOST="$(get_hostname_color)"
    local PROMPT_PATH="\[\e[00;37m\]\w\[\e[0m\]"
    local prompt_text="$PROMPT_DATE $(__git_ps1)\n$PROMPT_USER_NAME$PROMPT_AT$PROMPT_HOST $PROMPT_PATH"
    echo $prompt_text
}

function prompt {
    if [[ $? -eq 0 ]]; then
        set_prompt_good
    else
        set_prompt_bad
    fi
}

function c () {
    [ ! "$1" ] && cd ~ && ls --color=auto && return 0;
    cd "$1" && ls --color=auto
}

function hist {
    cat ~/.backup/history_*.txt >> ~/.backup/history.txt
    uniq ~/.backup/history.txt > ~/.backup/history.txt.back
    mv ~/.backup/history.txt.back ~/.backup/history.txt
    if [[ -f ~/.backup/history.txt ]]; then
        grep "$1" ~/.backup/history.txt
    else
        history | grep "$1"
    fi
    rm -rf ~/.backup/history_*.txt
}

function tm {
    tmux new-session -s default -d 
    tmux new-window -t default
    tmux new-window -t default
    tmux new-window -t default
    tmux new-window -t default
    tmux -2 attach-session -t default
}

function gst {
    for f in $(find ./ -name .git -type d); do
        local git_cherry
        git_cherry=$(git --git-dir "$f" cherry -v | sed 's/^/    /g')
        if [[ "$git_cherry" != "" ]]; then
            echo "$f $(git --git-dir "$f" rev-parse HEAD)";
            echo "$git_cherry"
        fi
    done
}
