
function setup_xdbus {
    local dbus="$HOME/.dbus/Xdbus"
    if [[ ! -f "$dbus" ]]; then
        touch "$dbus"
        chmod 600 "$dbus"
        env | grep DBUS_SESSION_BUS_ADDRESS > "$dbus"
        echo 'export DBUS_SESSION_BUS_ADDRESS' >> "$dbus"
    fi
}

function hgp {
    HGP_BACKUP_DIR=$HOME/.backup/patch/
    local name=""
    if [[ $1 ]]; then
        name="_$(echo "$*" | tr -s ' ' '_')_"
    fi
    local outfile="$(date +'%Y%m%d_%H%M%S')$name.patch"
    hg diff . > "$outfile"
    [[ -d $HGP_BACKUP_DIR ]] || mkdir -p "$HGP_BACKUP_DIR"
    cp "$outfile" "$HGP_BACKUP_DIR";
    echo "cp $outfile $HGP_BACKUP_DIR;"
}

HISTORY_TMP=/home/$USER/.backup/history.txt
function save_last_command {
    echo "$(date) $(hostname) [$(pwd)] $(history | tail -1)" >> "$HISTORY_TMP"
}

function get_username_color {
    if [[ "$(whoami)" == "root" ]]; then
        echo "\[\e[00;31m\]<><><> ROOT <><><>\[\e[0m\]"
        return
    fi
    local hhash=$(whoami| md5sum | grep "[0-9]" -o | paste -s -d+ - |bc)
    local hash_number=$(( hhash % 14 ))
    #echo "username $(whoami) hash $hhash hash_number $hash_number"
    case $hash_number in
         0) echo "\[\e[00;37m\]\u\[\e[0m\]";; ## username_white
         1) echo "\[\e[00;31m\]\u\[\e[0m\]";; ## username_red
         2) echo "\[\e[00;32m\]\u\[\e[0m\]";; ## username_green
         3) echo "\[\e[00;33m\]\u\[\e[0m\]";; ## username_yellow
         4) echo "\[\e[00;31m\]\u\[\e[0m\]";; ## username_red
         #4) echo "\[\e[00;34m\]\u\[\e[0m\]";; ## username_blue # not readable
         5) echo "\[\e[00;35m\]\u\[\e[0m\]";; ## username_purple
         6) echo "\[\e[00;35m\]\u\[\e[0m\]";; ## username_cyan
         ## bold colors
         7) echo "\[\e[01;37m\]\u\[\e[0m\]";; ## username_white
         8) echo "\[\e[01;31m\]\u\[\e[0m\]";; ## username_red
         9) echo "\[\e[01;32m\]\u\[\e[0m\]";; ## username_green
        10) echo "\[\e[01;33m\]\u\[\e[0m\]";; ## username_yellow
        11) echo "\[\e[01;31m\]\u\[\e[0m\]";; ## username_red
        #11) echo "\[\e[01;34m\]\u\[\e[0m\]";; ## username_blue # not readable
        12) echo "\[\e[01;35m\]\u\[\e[0m\]";; ## username_purple
        13) echo "\[\e[01;35m\]\u\[\e[0m\]";; ## username_cyan
    esac
}
function get_hostname_color {
    local hhash=$PROMPT_HOSTNAME_COLOR_HASH
    if [[ -z $hhash ]]; then
        hhash=$(hostname | md5sum | grep "[0-9]" -o | paste -s -d+ - |bc)
        export PROMPT_HOSTNAME_COLOR_HASH=$hhash
    fi
    local hash_number=$(( hhash % 14 ))
    case $hash_number in
         0) echo "\[\e[00;37m\]\h\[\e[0m\]";; ## hostname_white
         1) echo "\[\e[00;31m\]\h\[\e[0m\]";; ## hostname_red
         2) echo "\[\e[00;32m\]\h\[\e[0m\]";; ## hostname_green
         3) echo "\[\e[00;33m\]\h\[\e[0m\]";; ## hostname_yellow
         4) echo "\[\e[00;31m\]\h\[\e[0m\]";; ## hostname_red
         #4) echo "\[\e[00;34m\]\h\[\e[0m\]";; ## hostname_blue # not readable
         5) echo "\[\e[00;35m\]\h\[\e[0m\]";; ## hostname_purple
         6) echo "\[\e[00;35m\]\h\[\e[0m\]";; ## hostname_cyan
         ## bold colors
         7) echo "\[\e[01;37m\]\h\[\e[0m\]";; ## hostname_white
         8) echo "\[\e[01;31m\]\h\[\e[0m\]";; ## hostname_red
         9) echo "\[\e[01;32m\]\h\[\e[0m\]";; ## hostname_green
        10) echo "\[\e[01;33m\]\h\[\e[0m\]";; ## hostname_yellow
        11) echo "\[\e[01;31m\]\h\[\e[0m\]";; ## hostname_red
        #11) echo "\[\e[01;34m\]\h\[\e[0m\]";; ## hostname_blue # not readable
        12) echo "\[\e[01;35m\]\h\[\e[0m\]";; ## hostname_purple
        13) echo "\[\e[01;35m\]\h\[\e[0m\]";; ## hostname_cyan
    esac
}

function update_git_prompt {
    git rev-parse --git-dir &> /dev/null
    if [[ "$?" -ne "0" ]]; then
        export GIT_PROMPT=""
        return
    fi

    local git_root="$(basename "$(git rev-parse --show-toplevel)")"
    local current_branch="$(git branch | grep "^\*" | sed 's/^\* //')"
    CURRENT_BRANCH="\[\033[38;5;160m\][$current_branch]\[$(tput sgr0)\]"


    FILE_STATUS=""
    local untracked=$(git ls-files --others --exclude-standard | wc -l)
    if [[ "$untracked" -ne "0" ]]; then
        FILE_STATUS="\[\033[38;5;11m\]?\[$(tput sgr0)\]"
    fi
    local changed="$(git status | grep -c "modified:")"
    if [[ "$changed" -ne "0" ]]; then
        FILE_STATUS="$FILE_STATUS\[\033[38;5;208m\]++\[$(tput sgr0)\]"
    fi

    local outgoing="$(git log --branches --not --remotes=origin | wc -l)"
    local git_changes=""
    if [[ "$outgoing"  -ne "0" ]]; then
        git_changes=">>>>"
    fi

    GIT_PROMPT="$FILE_STATUS  $git_changes $CURRENT_BRANCH $git_root"
}

function update_battery_prompt {
    export BATTERY_PROMPT=""
    if [[ "$(acpi 2>&1 | grep Discharging -c)" -eq 1 ]]; then
        BATTERY_PROMPT="$(acpi | grep Discharging | cut -d ' ' -f4 | tr -d ',') "
    fi
}

function set_prompt_good {
    local EXIT_STATUS_GOOD="\[\e[00;32m\]#\[\e[0m\]"
    export PS1="$(set_prompt)\n$EXIT_STATUS_GOOD"
}

function set_prompt_bad {
    local EXIT_STATUS_BAD="\[\e[00;31m\]#\[\e[0m\]"
    export PS1="$(set_prompt)\n$EXIT_STATUS_BAD"
}

function set_prompt {
    #update_git_prompt
    #update_battery_prompt
    local PROMPT_DATE="\[\033[38;5;10m\]\d\[$(tput sgr0)\]\[\033[38;5;15m\] \[$(tput sgr0)\]\[\033[38;5;10m\]\t\[$(tput sgr0)\]"
    local PROMPT_USER_NAME="$(get_username_color)"
    local PROMPT_AT="\[\e[00;37m\]@\[\e[0m\]"
    local PROMPT_HOST="$(get_hostname_color)"
    local PROMPT_PATH="\[\e[00;37m\]\w\[\e[0m\]"
    local prompt_text="$PROMPT_DATE $(__git_ps1)\n$PROMPT_USER_NAME$PROMPT_AT$PROMPT_HOST $PROMPT_PATH"
    echo $prompt_text
}

function prompt {
    if [[ $? -eq 0 ]]; then
        set_prompt_good
    else
        set_prompt_bad
    fi
}

function c () {
    [ ! "$1" ] && cd ~ && ls --color=auto && return 0;
    cd "$1" && ls --color=auto
}

function mkrole {
    mkdir -p roles/"$1"/tasks
    mkdir -p roles/"$1"/vars
    mkdir -p roles/"$1"/handlers
    mkdir -p roles/"$1"/templates
    for f in roles/"$1"/handlers/main.yml roles/"$1"/tasks/main.yml ; do
        [[ -f "$f" ]] || echo "---" > "$f"
    done
}

function hist {
    cat ~/.backup/history_*.txt >> ~/.backup/history.txt
    uniq ~/.backup/history.txt > ~/.backup/history.txt.back
    mv ~/.backup/history.txt.back ~/.backup/history.txt
    if [[ -f ~/.backup/history.txt ]]; then
        grep "$1" ~/.backup/history.txt
    else
        history | grep "$1"
    fi
    rm -rf ~/.backup/history_*.txt
}

function tm {
    tmux new-session -s default -d 
    tmux new-window -t default
    tmux new-window -t default
    tmux new-window -t default
    tmux new-window -t default
    tmux -2 attach-session -t default
}

function vm_get_ip {
    vboxmanage guestproperty enumerate "$1" 2>&1 | grep "/VirtualBox/GuestInfo/Net/0/V4/IP" | perl -p -e 's/.*value: ([0-9\.]*).*/$1/'
}

function vm {
    case "$1" in
        up|update)
            cd ~/di/ansible
            ansible-playbook new-virtualbox.yml -i hosts --tags=devel;;
        new)
            cd ~/di/ansible
            ansible-playbook new-virtualbox.yml -i hosts;;
        ls|list)
            local running="$(vboxmanage list runningvms | grep -o '{.*}' | tr -s '\n' '|')"
            IFS=$(echo -en "\n\b")
            for f in $(vboxmanage list vms); do
                local name=$(echo "$f" | grep -oP "{.*}")
                local ram=$(vboxmanage showvminfo "$name" 2>&1 | grep "^Memory")
                if [[ $? -ne 0 ]]; then
                    ram="nada"
                fi
                local ip=$(vm_get_ip "$name")
                if [[ $? -ne 0 ]]; then
                    ip=""
                fi
                echo "$f $ram $ip" | GREP_COLOR='1;32' grep -E "$running"
            done
            ;;
        del)
            if [[ -z "$2" ]]; then
                for f in $(vboxmanage list runningvms | cut -d\  -f2); do
                    vboxmanage controlvm "$f" poweroff;
                done
            else
                vboxmanage controlvm "$2" poweroff;
            fi
            ;;
        st)
            local ram_size_mod=$(echo "$@" | grep -oP "\s(\+|\-){0,1}\d*" | tr -d '\n' | tr -d ' ')
            local vm_name="$2"
            echo "$vm_name [$ram_size_mod]"
            if [[ "$ram_size_mod" ]]; then
                # readjust ram
                echo "readjusting"
                local ram_01=$(vboxmanage showvminfo "$vm_name" | grep "^Memory" | cut -d ':' -f2 | perl -p -e 's/\s+//' | perl -p -e 's/MB//')
                local new_ram=$(( ram_01 + ram_size_mod ))
                vboxmanage modifyvm "$vm_name" --memory $new_ram
            fi
            vboxmanage startvm "$vm_name" --type headless
            local ip=""
            while [[ -z "$ip" ]]; do
                ip=$(vm_get_ip "$vm_name")
            done
            
            ;;
    esac
}

function gb {
    local url="https://$(git remote -v | grep fetch | awk '{ print $2 }' | perl -p -e 's/^(ssh|http|https):\/\///' | perl -p -e 's/git@(.*)$/$1/g' | perl -p -e 's/\.git$//g')"
    local extra=""
    case $1 in
        gl)
            extra="network/master"
            ;;
        new)
            extra="issues/new"
            ;;
        iss*)
            extra="issues"
            ;;
        *)
            ;;
    esac
    echo "$url/$extra"
    google-chrome "$url/$extra"
}

function gst {
    for f in $(find ./ -name .git -type d); do
        local git_cherry
        git_cherry=$(git --git-dir "$f" cherry -v | sed 's/^/    /g')
        if [[ "$git_cherry" != "" ]]; then
            echo "$f $(git --git-dir "$f" rev-parse HEAD)";
            echo "$git_cherry"
        fi
    done
}
