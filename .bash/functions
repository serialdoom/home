# vi: ft=sh

function setup_xdbus {
    local dbus="$HOME/.dbus/Xdbus"
    if [[ ! -f "$dbus" ]]; then
        touch "$dbus"
        chmod 600 "$dbus"
        env | grep DBUS_SESSION_BUS_ADDRESS > "$dbus"
        echo 'export DBUS_SESSION_BUS_ADDRESS' >> "$dbus"
    fi
}

function hgp {
    HGP_BACKUP_DIR=$HOME/.backup/patch/
    local name=""
    if [[ $1 ]]; then
        name="_$(echo "$*" | tr -s ' ' '_')_"
    fi
    local outfile="$(date +'%Y%m%d_%H%M%S')$name.patch"
    hg diff . > "$outfile"
    [[ -d $HGP_BACKUP_DIR ]] || mkdir -p "$HGP_BACKUP_DIR"
    cp "$outfile" "$HGP_BACKUP_DIR";
    echo "cp $outfile $HGP_BACKUP_DIR;"
}

HISTORY_TMP=/home/$USER/.backup/history.txt
function save_last_command {
    echo "$(date) $(hostname) [$(pwd)] $(history | tail -1)" >> "$HISTORY_TMP"
}

function get_username_color {
    if [[ "$(whoami)" == "root" ]]; then
        echo "\[\e[00;31m\]<><><> ROOT <><><>\[\e[0m\]"
        return
    fi
    local hhash=$(whoami| md5sum | grep "[0-9]" -o | paste -s -d+ - |bc)
    local hash_number=$(( hhash % 14 ))
    #echo "username $(whoami) hash $hhash hash_number $hash_number"
    case $hash_number in
         0) echo "\[\e[00;37m\]\u\[\e[0m\]";; ## username_white
         1) echo "\[\e[00;31m\]\u\[\e[0m\]";; ## username_red
         2) echo "\[\e[00;32m\]\u\[\e[0m\]";; ## username_green
         3) echo "\[\e[00;33m\]\u\[\e[0m\]";; ## username_yellow
         4) echo "\[\e[00;31m\]\u\[\e[0m\]";; ## username_red
         #4) echo "\[\e[00;34m\]\u\[\e[0m\]";; ## username_blue # not readable
         5) echo "\[\e[00;35m\]\u\[\e[0m\]";; ## username_purple
         6) echo "\[\e[00;35m\]\u\[\e[0m\]";; ## username_cyan
         ## bold colors
         7) echo "\[\e[01;37m\]\u\[\e[0m\]";; ## username_white
         8) echo "\[\e[01;31m\]\u\[\e[0m\]";; ## username_red
         9) echo "\[\e[01;32m\]\u\[\e[0m\]";; ## username_green
        10) echo "\[\e[01;33m\]\u\[\e[0m\]";; ## username_yellow
        11) echo "\[\e[01;31m\]\u\[\e[0m\]";; ## username_red
        #11) echo "\[\e[01;34m\]\u\[\e[0m\]";; ## username_blue # not readable
        12) echo "\[\e[01;35m\]\u\[\e[0m\]";; ## username_purple
        13) echo "\[\e[01;35m\]\u\[\e[0m\]";; ## username_cyan
    esac
}
function get_hostname_color {
    local hhash=$PROMPT_HOSTNAME_COLOR_HASH
    if [[ -z $hhash ]]; then
        hhash=$(hostname | md5sum | grep "[0-9]" -o | paste -s -d+ - |bc)
        export PROMPT_HOSTNAME_COLOR_HASH=$hhash
    fi
    local hash_number=$(( hhash % 14 ))
    case $hash_number in
         0) echo "\[\e[00;37m\]\h\[\e[0m\]";; ## hostname_white
         1) echo "\[\e[00;31m\]\h\[\e[0m\]";; ## hostname_red
         2) echo "\[\e[00;32m\]\h\[\e[0m\]";; ## hostname_green
         3) echo "\[\e[00;33m\]\h\[\e[0m\]";; ## hostname_yellow
         4) echo "\[\e[00;31m\]\h\[\e[0m\]";; ## hostname_red
         #4) echo "\[\e[00;34m\]\h\[\e[0m\]";; ## hostname_blue # not readable
         5) echo "\[\e[00;35m\]\h\[\e[0m\]";; ## hostname_purple
         6) echo "\[\e[00;35m\]\h\[\e[0m\]";; ## hostname_cyan
         ## bold colors
         7) echo "\[\e[01;37m\]\h\[\e[0m\]";; ## hostname_white
         8) echo "\[\e[01;31m\]\h\[\e[0m\]";; ## hostname_red
         9) echo "\[\e[01;32m\]\h\[\e[0m\]";; ## hostname_green
        10) echo "\[\e[01;33m\]\h\[\e[0m\]";; ## hostname_yellow
        11) echo "\[\e[01;31m\]\h\[\e[0m\]";; ## hostname_red
        #11) echo "\[\e[01;34m\]\h\[\e[0m\]";; ## hostname_blue # not readable
        12) echo "\[\e[01;35m\]\h\[\e[0m\]";; ## hostname_purple
        13) echo "\[\e[01;35m\]\h\[\e[0m\]";; ## hostname_cyan
    esac
}

function update_git_prompt {
    git rev-parse --git-dir &> /dev/null
    if [[ "$?" -ne "0" ]]; then
        export GIT_PROMPT=""
        return
    fi

    local git_root="$(basename "$(git rev-parse --show-toplevel)")"
    local current_branch="$(git branch | grep "^\*" | sed 's/^\* //')"
    CURRENT_BRANCH="\[\033[38;5;160m\][$current_branch]\[$(tput sgr0)\]"


    FILE_STATUS=""
    local untracked=$(git ls-files --others --exclude-standard | wc -l)
    if [[ "$untracked" -ne "0" ]]; then
        FILE_STATUS="\[\033[38;5;11m\]?\[$(tput sgr0)\]"
    fi
    local changed="$(git status | grep -c "modified:")"
    if [[ "$changed" -ne "0" ]]; then
        FILE_STATUS="$FILE_STATUS\[\033[38;5;208m\]++\[$(tput sgr0)\]"
    fi

    local outgoing="$(git log --branches --not --remotes=origin | wc -l)"
    local git_changes=""
    if [[ "$outgoing"  -ne "0" ]]; then
        git_changes=">>>>"
    fi

    GIT_PROMPT="$FILE_STATUS  $git_changes $CURRENT_BRANCH $git_root"
}

function update_battery_prompt {
    export BATTERY_PROMPT=""
    if [[ "$(acpi 2>&1 | grep Discharging -c)" -eq 1 ]]; then
        BATTERY_PROMPT="$(acpi | grep Discharging | cut -d ' ' -f4 | tr -d ',') "
    fi
}

function set_prompt_good {
    local EXIT_STATUS_GOOD="\[\e[00;32m\]#\[\e[0m\]"
    export PS1="$(set_prompt)\n$EXIT_STATUS_GOOD"
}

function set_prompt_bad {
    local EXIT_STATUS_BAD="\[\e[00;31m\]#\[\e[0m\]"
    export PS1="$(set_prompt)\n$EXIT_STATUS_BAD"
}

function set_prompt {
    #update_git_prompt
    #update_battery_prompt
    if [[ $(uname) == 'Darwin' ]]; then
        local PROMPT_DATE=""
    else
        local PROMPT_DATE="\[\033[38;5;10m\]\d\[$(tput sgr0)\]\[\033[38;5;15m\] \[$(tput sgr0)\]\[\033[38;5;10m\]\t\[$(tput sgr0)\]"
    fi
    local PROMPT_USER_NAME="$(get_username_color)"
    local PROMPT_AT="\[\e[00;37m\]@\[\e[0m\]"
    local PROMPT_HOST="$(get_hostname_color)"
    local PROMPT_PATH="\[\e[00;37m\]\w\[\e[0m\]"
    local prompt_text="$PROMPT_DATE $VAGRANT_NETWORK_IFACE $(__git_ps1)\n$PROMPT_USER_NAME$PROMPT_AT$PROMPT_HOST $PROMPT_PATH"
    echo $prompt_text
}

function prompt {
    if [[ $? -eq 0 ]]; then
        set_prompt_good
    else
        set_prompt_bad
    fi
}

function c () {
    [ ! "$1" ] && cd ~ && ls && return 0;
    cd "$1" && ls
}

function aws_region {
    aws ec2 describe-regions | jq -r .Regions[].RegionName
}

function aws_vmlist {
    local region=$1
    if [[ -z $region ]]; then
        region=$(aws_region)
    fi
    for r in $region; do
        echo $r
        aws ec2 describe-instances --region $r | jq '.Reservations[].Instances[].Tags[] | join("/")'
    done
}
